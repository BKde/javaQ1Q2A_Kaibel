package baeume;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;

import _config.Configuration;

public class TreeViewer extends javax.swing.JFrame {
	
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	
	
	private BinaryTree<?> root;
	private javax.swing.JPanel canvas;


	private BinaryTree<?> highlightedTree;
	private String highlightedTreeContentString;
	private String repaintMonitorObject = "repaintMonitor";



	private static Font font;

	private static TreeViewer TREE_VIEWER_SINGLETON;

	private static boolean DO_HIGHLIGHT = false;
	private boolean DO_HIGHLIGHT_NODE = false;


	
	private TreeViewer() {
		super();

		Configuration.READ_AND_START_UPDATING_CONFIGURATION();
		font = new Font("Arial", Font.BOLD, Configuration.FONT_SIZE);
		int hoehe = Configuration.BAUM_ANZEIGE_HOEHE;
		int breite = Configuration.BAUM_ANZEIGE_BREITE;
		int posX = Configuration.BAUM_ANZEIGE_POS_X;
		int posY = Configuration.BAUM_ANZEIGE_POS_Y;
		initGUI(breite,hoehe, posX, posY);
	}

	private static void warte(int millis) {
		try {
			Thread.sleep(millis);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}


	public static void showTree(){
		if(TREE_VIEWER_SINGLETON == null){
			return;
		}
		DO_HIGHLIGHT = false;
		synchronized(TREE_VIEWER_SINGLETON.repaintMonitorObject){
			TREE_VIEWER_SINGLETON.repaint();
			warte(Configuration.WARTEZEIT_BAEUME);
			DO_HIGHLIGHT = true;
		}
	}
	
	public static void showTree(BinaryTree<?> pTree) {
		if (TREE_VIEWER_SINGLETON == null) {
			TREE_VIEWER_SINGLETON = new TreeViewer();
		}		
		if(TREE_VIEWER_SINGLETON == null){
			return;
		}
		TREE_VIEWER_SINGLETON.setBinaryTree(pTree);
		TREE_VIEWER_SINGLETON.setVisible(true);
		showTree();
	}

	public static void showTree(BinarySearchTree<?> pSearchTree) {
		showTree(pSearchTree.getBinaryTree());
	}
	
	public void highlight(BinaryTree<?> pTree, String pTreeContentString ){
		if(DO_HIGHLIGHT){
			synchronized(TreeViewer.this.repaintMonitorObject){
				TreeViewer.this.highlightedTree = pTree;
				TreeViewer.this.highlightedTreeContentString = pTreeContentString;
				new HighlightThread(true).start();				
				try {
					TreeViewer.this.repaintMonitorObject.wait();
				} catch (InterruptedException e) {
					System.out.println(e.getMessage());
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
			warte(Configuration.WARTEZEIT_BAEUME);
			synchronized(TreeViewer.this.repaintMonitorObject){
				TreeViewer.this.highlightedTree = pTree;
				TreeViewer.this.highlightedTreeContentString = pTreeContentString;
				new HighlightThread(false).start();
				try {
					TreeViewer.this.repaintMonitorObject.wait();
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
		}		
	}
	
	public static TreeViewer getSingleton(){
		return TREE_VIEWER_SINGLETON;
	}

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	private void initGUI(int width, int height, int posX, int posY) {
		BorderLayout layout = new BorderLayout();
		getContentPane().setLayout(layout);
		canvas = new javax.swing.JPanel();
		setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
		canvas.setBackground(new java.awt.Color(255, 255, 51));
		this.setSize(width,height);
		this.setPreferredSize(new java.awt.Dimension(width,height));
		this.getContentPane().add(canvas, BorderLayout.CENTER);
		this.setLocation(posX, posY);

	    this.addComponentListener(new ComponentAdapter() {
            @Override
            public void componentResized(ComponentEvent e) {
                int height = getHeight();
                int width = getWidth();
                Configuration.BAUM_ANZEIGE_HOEHE = height;
                Configuration.BAUM_ANZEIGE_BREITE = width;
            }
            @Override
            public void componentMoved(ComponentEvent e) {
                Configuration.BAUM_ANZEIGE_POS_X = getLocation().x;
                Configuration.BAUM_ANZEIGE_POS_Y = getLocation().y;          	
            }
        });			
		

		pack();

	}

	private void zeichnen(Graphics g, BinaryTree<?> b, int l, int r, int t) {
		g.setFont(font);
		if (b != null && !b.isEmpty()) {
			String s = b.getContent().toString();
			// System.out.println(s);
			int x = (int) ((l + r - s.length() * 7) / 2);
			g.setColor(Color.BLUE);
			g.drawString(s, x, t * 36);
			int x1 = (int) ((l + r) / 2);
			int y1 = t * 36 + 7;
			int x2 = (int) ((l + x1) / 2);
			int x3 = (int) ((x1 + r) / 2);
			int y2 = y1 + 36;
			g.setColor(Color.RED);
			if (b.getLeftTree() != null && !b.getLeftTree().isEmpty())
				g.drawLine(x1, y1, x2, y2);
			if (b.getRightTree() != null && !b.getRightTree().isEmpty())
				g.drawLine(x1, y1, x3, y2);
			g.fillOval(x1 - 3, y1 - 3, 6, 6);
			zeichnen(g, b.getLeftTree(), l, (int) (l + r) / 2, t + 1);
			zeichnen(g, b.getRightTree(), (int) (l + r) / 2, r, t + 1);
		}
		
	}

	/**
	 * zeigt den BinaryTree b bzw. rekursiv eines seiner Kinder als highlighted an.
	 * Voraussetzung: b == this.highlightedTree
	 * @param g
	 * @param b
	 * @param l
	 * @param r
	 * @param t
	 * @param highlighted
	 */
	private void highlightNode(Graphics g, BinaryTree<?> b, int l, int r, int t, boolean highlighted) {
		if(highlightedTree == null){
			return;
		}
		g.setFont(font);
		if (b != null && !b.isEmpty()) {
			if(b == this.highlightedTree){
				String s = this.highlightedTreeContentString;
				if(highlighted){
					//g.setColor(Color.RED);
					//g.setColor(new Color(255, 102, 102));		
					g.setColor(new Color(144, 238, 144)); // Light Green
				}
				else{
					g.setColor(Color.BLUE);
				}
				int x = (int) ((l + r - s.length() * 7) / 2);
				g.drawString(s, x, t * 36);
				warte(Configuration.WARTEZEIT_BAEUME);
			}
			int x1 = (int) ((l + r) / 2);
			int y1 = t * 36 + 7;
			highlightNode(g, b.getLeftTree(), l, (int) (l + r) / 2, t + 1, highlighted);
			highlightNode(g, b.getRightTree(), (int) (l + r) / 2, r, t + 1, highlighted);
		}
		
	}

	private void setBinaryTree(BinaryTree<?> baum) {
		root = baum;
		DO_HIGHLIGHT = false;
		repaint();
		//DO_HIGHLIGHT = true;
	}

	private void setBinarySearchTree(BinarySearchTree<?> bst) {
		setBinaryTree(bst.getBinaryTree());
	}

	@Override
	public void paint(Graphics g) {
		synchronized(this.repaintMonitorObject){
			if(DO_HIGHLIGHT && this.highlightedTreeContentString != null){
					// nur einen Knoten highlighten
					//System.out.println("paint highlight: "+this.highlightedTreeContentString+": "+DO_HIGHLIGHT_NODE);
					g.translate(0, 15);	
					highlightNode(g, root,1,canvas.getWidth(),1, DO_HIGHLIGHT_NODE);
					this.highlightedTree = null;
					this.highlightedTreeContentString = null;
					this.repaintMonitorObject.notify();
			}
			else{
					// ganzen Baum zeichnen
					//System.out.println("Baum neu zeichnen");
					DO_HIGHLIGHT = false;
					super.paint(g);
					g.translate(0, 15);			
					g.setColor(Color.YELLOW);
					g.fillRect(0, 0, canvas.getSize().width, canvas.getSize().height);
					zeichnen(g, root, 1, canvas.getWidth(), 1);
					DO_HIGHLIGHT = true;
					this.repaintMonitorObject.notify();
			}
		}

	}
	
	private class HighlightThread extends Thread{
		private boolean doHighlight;

		HighlightThread(boolean doHighlight){
			this.doHighlight = doHighlight;
		}
		
		public void run(){
			TreeViewer.this.DO_HIGHLIGHT_NODE = doHighlight;
			//System.out.println("HighlightThread: "+highlightedTreeContentString+": "+doHighlight);
			repaint();
		}
	}

}
